０、仕様
・last hash asked の仕様は？
マスターのbestハッシュ値か、インポートに失敗したブロックの親がセットされる。
GetBlockHashesByNumberによって、既知の部分から一定数ずつ昇順にハッシュ値を取得していく。
そして、GetBlocksは未消化のハッシュ値を一定数ずつ消化するだけ。

・https://github.com/ethereum/go-ethereum/wiki/RLPx-----Node-Discovery-Protocol
に基いてコメントを書く。
・secp256k1 について学ぶ。
・Encryption Handshakeについて。
https://github.com/ethereum/devp2p/blob/master/rlpx.md
・NewBlockとは何か？
https://github.com/ethereum/wiki/wiki/Ethereum-Wire-Protocol
・node discovery protocol と secure transport protocolが兄弟関係なわけだ。
・mdc = modification detection code
・mac = message authentication code
・idle 等の状態遷移の仕様
・pending transactionの意味は？
・PeerIdを文字列で扱うのは正式仕様なのか？
・gap recoveryは？
・fill up nodesは？

０、不具合
・どうもコネクションタイムアウトしすぎではないか。
←何かの約束違反を犯している？　あるいは、これが正常な動作であるのか。
←プロセッサ負荷が高すぎて、pingを送れていないのではないかという仮説。以下と合わせて。
←mediumにしても、10万手前の難関で落とされるように見える。
インスタンスを変えるか、yield でうまくやるか、タイムアウト時間を延ばすか。インスタンスは、c4.large が良いかもしれない。
c4.large (vCPU=2, ECU=8) では 236,246まで行ったが、苦しい。プロセッサ限界によると思われる接続切れが発生した。
c4.xlarge (vCPU=4, ECU=16) にすると、top の CPU使用率がほぼ常時200%を超える（300%を超える時間帯も長く、377%を確認）ので、やはりc4.largeでは足りなかったのだ。
c4.xlarge でも、Block[262,929]処理中に、
2016-01-07 11:01:42.553 INFO  <TxExecutor> Withdraw in advance: TxManaCost: 70,000,000,000,000,000, ManaPrice: 70,000,000,000, ManaLimit: 1,000,000 [sync-queue-000] TransactionExecutor.scala:86
で固まる現象が発生。前回とまったく同じ箇所！ 呼び出されるコントラクトが長い。これをよく調べるべきだ。
Tx: 0x95def7f925d36c4f459200e2c29213878a97d4e0708b6396885da03b2ec1b9a1

・１時間もの断絶が発生している。考えられないことだ。スレッド数過大か。topはJava100%。
2016-01-06 01:13:44.659 INFO  <TxExecutor> Withdraw in advance: TxManaCost: 70,000,000,000,000,000, ManaPrice: 70,000,000,000, ManaLimit: 1,000,000 [Thread-4] TransactionExecutor.scala:85
2016-01-06 02:19:33.374 DEBUG <TxExecutor> Contract invocation: [1194e966965418c7d73a42cceeb254d875860356]=[1,823 bytes] [Thread-4] TransactionExecutor.scala:137

・Fill up できないのはどういう時？←既知であるかTDが低いとき。

・Caused by: java.net.SocketException: Too many open files
← lsof -c java リソースリーク疑惑。UDP不通問題が解消されて顕在化したのだから、TCPの接続が疑わしいか。
PingやPongのゼロバイト問題は？

・ストレージ操作に時間を消費している可能性もある？
←可能性は高くないが、ストレージ関係の出力をまとめよう。


１、既存環境との完全同期
・Ping、Pong、Neighboursについて、UDPとTCPのポートを分ける。
・ブロック情報の保存と再生を実行する。
・Active Peerについて考えなおす。
・BlockchainImpl の連結失敗時のエラー処理が甘い。
・CallTransactionの変更に追随する。
・もらうブロックはどうやって決まる？　場合によってはもう少し頻繁に flush した方がよいかも。

２、自前ノード間での動作＆トランザクション実行
・miningの具体的な方法を実装する。
・Validationの厳密化とインターフェイス統一。
・実データを見ながらのほうがいいかもしれない。

３、整備
・サーバーかクライアントかはわからないか？

・再起動するとエラー。
・gracefulな終了を実現する。
・expirationによるdiscardを実装する。（replay attack対策）
・WARNは別のログに出した方が良かろう。
・アウトラインログを作る。（特にマスターのスイッチ）
・refactorする。（init() や start() の整備。future化。）
・logging、refactor、comment。（不具合追跡用）
・多数のJARファイルは、ディスクリプタ数の面で非常に不利。
・ECKeyを実装し直す。（ECの仕様とシステムの仕様を両方よく検討する必要がある。）
・nullを排除する。
・ImmutableBytes#toByteArray を排除する。

とにかく yellow paper を熟読すること。
ethashを学ぶと、mixhashがわかる。

git flowを入れる。

https://github.com/ethereum/tests を活用した自動テストの実行方法を考える。

BlockchainImplの精緻なテスト。
IndexedBlockStoreのテストを充実させる。
VMTest、VMCustomTest、VMComplexTest等々を充実させる。

StorageDictionary関連は、よく意味がわかっていないので後回しとする。
VM関連のデバッグ用出力（ProgramTrace等）。
RepositoryImplのデバッグ用出力。
TransactionExecutorのデバッグ用出力。
LpcHandlerのデバッグ用出力。
PeersPoolのデバッグ用出力。


依存先およびライセンスをまとめる。
楕円曲線暗号について調べる。

sbtによるleveldbのテストの問題？
